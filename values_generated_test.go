package sflags

// This file is autogenerated by "go generate .". Do not modify.

import (
	"net"
	"regexp"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
)

func TestStringValue_Zero(t *testing.T) {
	nilValue := new(stringValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*stringValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestStringValue(t *testing.T) {
	t.Run("in: string", func(t *testing.T) {
		a := new(string)
		v := newStringValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("string")
		assert.Nil(t, err)
		assert.Equal(t, "string", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "string", v.Type())
	})

}

func TestStringSliceValue_Zero(t *testing.T) {
	nilValue := new(stringSliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*stringSliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestStringStringMapValue_Zero(t *testing.T) {
	nilValue := new(stringStringMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*stringStringMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIntStringMapValue_Zero(t *testing.T) {
	nilValue := new(intStringMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*intStringMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt8StringMapValue_Zero(t *testing.T) {
	nilValue := new(int8StringMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int8StringMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt16StringMapValue_Zero(t *testing.T) {
	nilValue := new(int16StringMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int16StringMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt32StringMapValue_Zero(t *testing.T) {
	nilValue := new(int32StringMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int32StringMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt64StringMapValue_Zero(t *testing.T) {
	nilValue := new(int64StringMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int64StringMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUintStringMapValue_Zero(t *testing.T) {
	nilValue := new(uintStringMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uintStringMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint8StringMapValue_Zero(t *testing.T) {
	nilValue := new(uint8StringMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint8StringMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint16StringMapValue_Zero(t *testing.T) {
	nilValue := new(uint16StringMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint16StringMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint32StringMapValue_Zero(t *testing.T) {
	nilValue := new(uint32StringMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint32StringMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint64StringMapValue_Zero(t *testing.T) {
	nilValue := new(uint64StringMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint64StringMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestStringSliceValue(t *testing.T) {
	t.Run("in: [val1,val2 val3,val4]", func(t *testing.T) {
		var err error
		a := new([]string)
		v := newStringSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("val1,val2")
		assert.Nil(t, err)
		err = v.Set("val3,val4")
		assert.Nil(t, err)
		assert.Equal(t, "[val1,val2,val3,val4]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "stringSlice", v.Type())
	})

}

func TestBoolValue_Zero(t *testing.T) {
	nilValue := new(boolValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*boolValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestBoolValue(t *testing.T) {
	t.Run("in: true", func(t *testing.T) {
		a := new(bool)
		v := newBoolValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("true")
		assert.Nil(t, err)
		assert.Equal(t, "true", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "bool", v.Type())
	})
	t.Run("in: false", func(t *testing.T) {
		a := new(bool)
		v := newBoolValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("false")
		assert.Nil(t, err)
		assert.Equal(t, "false", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "bool", v.Type())
	})
	t.Run("in: 1", func(t *testing.T) {
		a := new(bool)
		v := newBoolValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("1")
		assert.Nil(t, err)
		assert.Equal(t, "true", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "bool", v.Type())
	})
	t.Run("in: 0", func(t *testing.T) {
		a := new(bool)
		v := newBoolValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("0")
		assert.Nil(t, err)
		assert.Equal(t, "false", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "bool", v.Type())
	})
	t.Run("in: unexpected", func(t *testing.T) {
		a := new(bool)
		v := newBoolValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("unexpected")
		assert.EqualError(t, err, "strconv.ParseBool: parsing \"unexpected\": invalid syntax")
		assert.Equal(t, "false", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "bool", v.Type())
	})

}

func TestBoolSliceValue_Zero(t *testing.T) {
	nilValue := new(boolSliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*boolSliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestStringBoolMapValue_Zero(t *testing.T) {
	nilValue := new(stringBoolMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*stringBoolMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIntBoolMapValue_Zero(t *testing.T) {
	nilValue := new(intBoolMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*intBoolMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt8BoolMapValue_Zero(t *testing.T) {
	nilValue := new(int8BoolMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int8BoolMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt16BoolMapValue_Zero(t *testing.T) {
	nilValue := new(int16BoolMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int16BoolMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt32BoolMapValue_Zero(t *testing.T) {
	nilValue := new(int32BoolMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int32BoolMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt64BoolMapValue_Zero(t *testing.T) {
	nilValue := new(int64BoolMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int64BoolMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUintBoolMapValue_Zero(t *testing.T) {
	nilValue := new(uintBoolMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uintBoolMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint8BoolMapValue_Zero(t *testing.T) {
	nilValue := new(uint8BoolMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint8BoolMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint16BoolMapValue_Zero(t *testing.T) {
	nilValue := new(uint16BoolMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint16BoolMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint32BoolMapValue_Zero(t *testing.T) {
	nilValue := new(uint32BoolMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint32BoolMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint64BoolMapValue_Zero(t *testing.T) {
	nilValue := new(uint64BoolMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint64BoolMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestBoolSliceValue(t *testing.T) {
	t.Run("in: [true,false true]", func(t *testing.T) {
		var err error
		a := new([]bool)
		v := newBoolSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("true,false")
		assert.Nil(t, err)
		err = v.Set("true")
		assert.Nil(t, err)
		assert.Equal(t, "[true,false,true]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "boolSlice", v.Type())
	})
	t.Run("in: [true,unexpected]", func(t *testing.T) {
		var err error
		a := new([]bool)
		v := newBoolSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("true,unexpected")
		assert.EqualError(t, err, "strconv.ParseBool: parsing \"unexpected\": invalid syntax")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "boolSlice", v.Type())
	})

}

func TestUintValue_Zero(t *testing.T) {
	nilValue := new(uintValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uintValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUintValue(t *testing.T) {
	t.Run("in: 18446744073709551615", func(t *testing.T) {
		a := new(uint)
		v := newUintValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("18446744073709551615")
		assert.Nil(t, err)
		assert.Equal(t, "18446744073709551615", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint", v.Type())
	})
	t.Run("in: 18446744073709551616", func(t *testing.T) {
		a := new(uint)
		v := newUintValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("18446744073709551616")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"18446744073709551616\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint", v.Type())
	})
	t.Run("in: -1", func(t *testing.T) {
		a := new(uint)
		v := newUintValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-1")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint", v.Type())
	})
	t.Run("in: a", func(t *testing.T) {
		a := new(uint)
		v := newUintValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("a")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"a\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint", v.Type())
	})

}

func TestUintSliceValue_Zero(t *testing.T) {
	nilValue := new(uintSliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uintSliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestStringUintMapValue_Zero(t *testing.T) {
	nilValue := new(stringUintMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*stringUintMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIntUintMapValue_Zero(t *testing.T) {
	nilValue := new(intUintMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*intUintMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt8UintMapValue_Zero(t *testing.T) {
	nilValue := new(int8UintMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int8UintMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt16UintMapValue_Zero(t *testing.T) {
	nilValue := new(int16UintMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int16UintMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt32UintMapValue_Zero(t *testing.T) {
	nilValue := new(int32UintMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int32UintMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt64UintMapValue_Zero(t *testing.T) {
	nilValue := new(int64UintMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int64UintMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUintUintMapValue_Zero(t *testing.T) {
	nilValue := new(uintUintMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uintUintMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint8UintMapValue_Zero(t *testing.T) {
	nilValue := new(uint8UintMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint8UintMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint16UintMapValue_Zero(t *testing.T) {
	nilValue := new(uint16UintMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint16UintMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint32UintMapValue_Zero(t *testing.T) {
	nilValue := new(uint32UintMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint32UintMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint64UintMapValue_Zero(t *testing.T) {
	nilValue := new(uint64UintMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint64UintMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUintSliceValue(t *testing.T) {
	t.Run("in: [10,20 0]", func(t *testing.T) {
		var err error
		a := new([]uint)
		v := newUintSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("10,20")
		assert.Nil(t, err)
		err = v.Set("0")
		assert.Nil(t, err)
		assert.Equal(t, "[10,20,0]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uintSlice", v.Type())
	})
	t.Run("in: [-1,0]", func(t *testing.T) {
		var err error
		a := new([]uint)
		v := newUintSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("-1,0")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uintSlice", v.Type())
	})

}

func TestUint8Value_Zero(t *testing.T) {
	nilValue := new(uint8Value)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint8Value)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint8Value(t *testing.T) {
	t.Run("in: 255", func(t *testing.T) {
		a := new(uint8)
		v := newUint8Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("255")
		assert.Nil(t, err)
		assert.Equal(t, "255", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint8", v.Type())
	})
	t.Run("in: 256", func(t *testing.T) {
		a := new(uint8)
		v := newUint8Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("256")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"256\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint8", v.Type())
	})
	t.Run("in: -1", func(t *testing.T) {
		a := new(uint8)
		v := newUint8Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-1")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint8", v.Type())
	})
	t.Run("in: a", func(t *testing.T) {
		a := new(uint8)
		v := newUint8Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("a")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"a\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint8", v.Type())
	})

}

func TestUint8SliceValue_Zero(t *testing.T) {
	nilValue := new(uint8SliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint8SliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestStringUint8MapValue_Zero(t *testing.T) {
	nilValue := new(stringUint8MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*stringUint8MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIntUint8MapValue_Zero(t *testing.T) {
	nilValue := new(intUint8MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*intUint8MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt8Uint8MapValue_Zero(t *testing.T) {
	nilValue := new(int8Uint8MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int8Uint8MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt16Uint8MapValue_Zero(t *testing.T) {
	nilValue := new(int16Uint8MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int16Uint8MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt32Uint8MapValue_Zero(t *testing.T) {
	nilValue := new(int32Uint8MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int32Uint8MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt64Uint8MapValue_Zero(t *testing.T) {
	nilValue := new(int64Uint8MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int64Uint8MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUintUint8MapValue_Zero(t *testing.T) {
	nilValue := new(uintUint8MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uintUint8MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint8Uint8MapValue_Zero(t *testing.T) {
	nilValue := new(uint8Uint8MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint8Uint8MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint16Uint8MapValue_Zero(t *testing.T) {
	nilValue := new(uint16Uint8MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint16Uint8MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint32Uint8MapValue_Zero(t *testing.T) {
	nilValue := new(uint32Uint8MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint32Uint8MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint64Uint8MapValue_Zero(t *testing.T) {
	nilValue := new(uint64Uint8MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint64Uint8MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint8SliceValue(t *testing.T) {
	t.Run("in: [10,20 0]", func(t *testing.T) {
		var err error
		a := new([]uint8)
		v := newUint8SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("10,20")
		assert.Nil(t, err)
		err = v.Set("0")
		assert.Nil(t, err)
		assert.Equal(t, "[10,20,0]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint8Slice", v.Type())
	})
	t.Run("in: [-1,0]", func(t *testing.T) {
		var err error
		a := new([]uint8)
		v := newUint8SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("-1,0")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint8Slice", v.Type())
	})

}

func TestUint16Value_Zero(t *testing.T) {
	nilValue := new(uint16Value)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint16Value)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint16Value(t *testing.T) {
	t.Run("in: 65535", func(t *testing.T) {
		a := new(uint16)
		v := newUint16Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("65535")
		assert.Nil(t, err)
		assert.Equal(t, "65535", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint16", v.Type())
	})
	t.Run("in: 65536", func(t *testing.T) {
		a := new(uint16)
		v := newUint16Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("65536")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"65536\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint16", v.Type())
	})
	t.Run("in: -1", func(t *testing.T) {
		a := new(uint16)
		v := newUint16Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-1")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint16", v.Type())
	})
	t.Run("in: a", func(t *testing.T) {
		a := new(uint16)
		v := newUint16Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("a")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"a\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint16", v.Type())
	})

}

func TestUint16SliceValue_Zero(t *testing.T) {
	nilValue := new(uint16SliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint16SliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestStringUint16MapValue_Zero(t *testing.T) {
	nilValue := new(stringUint16MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*stringUint16MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIntUint16MapValue_Zero(t *testing.T) {
	nilValue := new(intUint16MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*intUint16MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt8Uint16MapValue_Zero(t *testing.T) {
	nilValue := new(int8Uint16MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int8Uint16MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt16Uint16MapValue_Zero(t *testing.T) {
	nilValue := new(int16Uint16MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int16Uint16MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt32Uint16MapValue_Zero(t *testing.T) {
	nilValue := new(int32Uint16MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int32Uint16MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt64Uint16MapValue_Zero(t *testing.T) {
	nilValue := new(int64Uint16MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int64Uint16MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUintUint16MapValue_Zero(t *testing.T) {
	nilValue := new(uintUint16MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uintUint16MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint8Uint16MapValue_Zero(t *testing.T) {
	nilValue := new(uint8Uint16MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint8Uint16MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint16Uint16MapValue_Zero(t *testing.T) {
	nilValue := new(uint16Uint16MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint16Uint16MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint32Uint16MapValue_Zero(t *testing.T) {
	nilValue := new(uint32Uint16MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint32Uint16MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint64Uint16MapValue_Zero(t *testing.T) {
	nilValue := new(uint64Uint16MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint64Uint16MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint16SliceValue(t *testing.T) {
	t.Run("in: [10,20 0]", func(t *testing.T) {
		var err error
		a := new([]uint16)
		v := newUint16SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("10,20")
		assert.Nil(t, err)
		err = v.Set("0")
		assert.Nil(t, err)
		assert.Equal(t, "[10,20,0]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint16Slice", v.Type())
	})
	t.Run("in: [-1,0]", func(t *testing.T) {
		var err error
		a := new([]uint16)
		v := newUint16SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("-1,0")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint16Slice", v.Type())
	})

}

func TestUint32Value_Zero(t *testing.T) {
	nilValue := new(uint32Value)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint32Value)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint32Value(t *testing.T) {
	t.Run("in: 4294967295", func(t *testing.T) {
		a := new(uint32)
		v := newUint32Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("4294967295")
		assert.Nil(t, err)
		assert.Equal(t, "4294967295", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint32", v.Type())
	})
	t.Run("in: 4294967296", func(t *testing.T) {
		a := new(uint32)
		v := newUint32Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("4294967296")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"4294967296\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint32", v.Type())
	})
	t.Run("in: -1", func(t *testing.T) {
		a := new(uint32)
		v := newUint32Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-1")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint32", v.Type())
	})
	t.Run("in: a", func(t *testing.T) {
		a := new(uint32)
		v := newUint32Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("a")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"a\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint32", v.Type())
	})

}

func TestUint32SliceValue_Zero(t *testing.T) {
	nilValue := new(uint32SliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint32SliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestStringUint32MapValue_Zero(t *testing.T) {
	nilValue := new(stringUint32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*stringUint32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIntUint32MapValue_Zero(t *testing.T) {
	nilValue := new(intUint32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*intUint32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt8Uint32MapValue_Zero(t *testing.T) {
	nilValue := new(int8Uint32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int8Uint32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt16Uint32MapValue_Zero(t *testing.T) {
	nilValue := new(int16Uint32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int16Uint32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt32Uint32MapValue_Zero(t *testing.T) {
	nilValue := new(int32Uint32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int32Uint32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt64Uint32MapValue_Zero(t *testing.T) {
	nilValue := new(int64Uint32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int64Uint32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUintUint32MapValue_Zero(t *testing.T) {
	nilValue := new(uintUint32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uintUint32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint8Uint32MapValue_Zero(t *testing.T) {
	nilValue := new(uint8Uint32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint8Uint32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint16Uint32MapValue_Zero(t *testing.T) {
	nilValue := new(uint16Uint32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint16Uint32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint32Uint32MapValue_Zero(t *testing.T) {
	nilValue := new(uint32Uint32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint32Uint32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint64Uint32MapValue_Zero(t *testing.T) {
	nilValue := new(uint64Uint32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint64Uint32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint32SliceValue(t *testing.T) {
	t.Run("in: [10,20 0]", func(t *testing.T) {
		var err error
		a := new([]uint32)
		v := newUint32SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("10,20")
		assert.Nil(t, err)
		err = v.Set("0")
		assert.Nil(t, err)
		assert.Equal(t, "[10,20,0]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint32Slice", v.Type())
	})
	t.Run("in: [-1,0]", func(t *testing.T) {
		var err error
		a := new([]uint32)
		v := newUint32SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("-1,0")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint32Slice", v.Type())
	})

}

func TestUint64Value_Zero(t *testing.T) {
	nilValue := new(uint64Value)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint64Value)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint64Value(t *testing.T) {
	t.Run("in: 18446744073709551615", func(t *testing.T) {
		a := new(uint64)
		v := newUint64Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("18446744073709551615")
		assert.Nil(t, err)
		assert.Equal(t, "18446744073709551615", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint64", v.Type())
	})
	t.Run("in: 18446744073709551616", func(t *testing.T) {
		a := new(uint64)
		v := newUint64Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("18446744073709551616")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"18446744073709551616\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint64", v.Type())
	})
	t.Run("in: -1", func(t *testing.T) {
		a := new(uint64)
		v := newUint64Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-1")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint64", v.Type())
	})
	t.Run("in: a", func(t *testing.T) {
		a := new(uint64)
		v := newUint64Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("a")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"a\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint64", v.Type())
	})

}

func TestUint64SliceValue_Zero(t *testing.T) {
	nilValue := new(uint64SliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint64SliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestStringUint64MapValue_Zero(t *testing.T) {
	nilValue := new(stringUint64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*stringUint64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIntUint64MapValue_Zero(t *testing.T) {
	nilValue := new(intUint64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*intUint64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt8Uint64MapValue_Zero(t *testing.T) {
	nilValue := new(int8Uint64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int8Uint64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt16Uint64MapValue_Zero(t *testing.T) {
	nilValue := new(int16Uint64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int16Uint64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt32Uint64MapValue_Zero(t *testing.T) {
	nilValue := new(int32Uint64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int32Uint64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt64Uint64MapValue_Zero(t *testing.T) {
	nilValue := new(int64Uint64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int64Uint64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUintUint64MapValue_Zero(t *testing.T) {
	nilValue := new(uintUint64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uintUint64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint8Uint64MapValue_Zero(t *testing.T) {
	nilValue := new(uint8Uint64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint8Uint64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint16Uint64MapValue_Zero(t *testing.T) {
	nilValue := new(uint16Uint64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint16Uint64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint32Uint64MapValue_Zero(t *testing.T) {
	nilValue := new(uint32Uint64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint32Uint64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint64Uint64MapValue_Zero(t *testing.T) {
	nilValue := new(uint64Uint64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint64Uint64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint64SliceValue(t *testing.T) {
	t.Run("in: [10,20 0]", func(t *testing.T) {
		var err error
		a := new([]uint64)
		v := newUint64SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("10,20")
		assert.Nil(t, err)
		err = v.Set("0")
		assert.Nil(t, err)
		assert.Equal(t, "[10,20,0]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint64Slice", v.Type())
	})
	t.Run("in: [-1,0]", func(t *testing.T) {
		var err error
		a := new([]uint64)
		v := newUint64SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("-1,0")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint64Slice", v.Type())
	})

}

func TestIntValue_Zero(t *testing.T) {
	nilValue := new(intValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*intValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIntValue(t *testing.T) {
	t.Run("in: 9223372036854775807", func(t *testing.T) {
		a := new(int)
		v := newIntValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("9223372036854775807")
		assert.Nil(t, err)
		assert.Equal(t, "9223372036854775807", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int", v.Type())
	})
	t.Run("in: -9223372036854775808", func(t *testing.T) {
		a := new(int)
		v := newIntValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-9223372036854775808")
		assert.Nil(t, err)
		assert.Equal(t, "-9223372036854775808", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int", v.Type())
	})
	t.Run("in: 0x10", func(t *testing.T) {
		a := new(int)
		v := newIntValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("0x10")
		assert.Nil(t, err)
		assert.Equal(t, "16", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int", v.Type())
	})
	t.Run("in: 0210", func(t *testing.T) {
		a := new(int)
		v := newIntValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("0210")
		assert.Nil(t, err)
		assert.Equal(t, "136", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int", v.Type())
	})
	t.Run("in: 0710", func(t *testing.T) {
		a := new(int)
		v := newIntValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("0710")
		assert.Nil(t, err)
		assert.Equal(t, "456", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int", v.Type())
	})
	t.Run("in: -9223372036854775809", func(t *testing.T) {
		a := new(int)
		v := newIntValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-9223372036854775809")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"-9223372036854775809\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int", v.Type())
	})
	t.Run("in: 9223372036854775808", func(t *testing.T) {
		a := new(int)
		v := newIntValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("9223372036854775808")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"9223372036854775808\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int", v.Type())
	})
	t.Run("in: a", func(t *testing.T) {
		a := new(int)
		v := newIntValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("a")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"a\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int", v.Type())
	})

}

func TestIntSliceValue_Zero(t *testing.T) {
	nilValue := new(intSliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*intSliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestStringIntMapValue_Zero(t *testing.T) {
	nilValue := new(stringIntMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*stringIntMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIntIntMapValue_Zero(t *testing.T) {
	nilValue := new(intIntMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*intIntMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt8IntMapValue_Zero(t *testing.T) {
	nilValue := new(int8IntMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int8IntMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt16IntMapValue_Zero(t *testing.T) {
	nilValue := new(int16IntMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int16IntMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt32IntMapValue_Zero(t *testing.T) {
	nilValue := new(int32IntMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int32IntMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt64IntMapValue_Zero(t *testing.T) {
	nilValue := new(int64IntMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int64IntMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUintIntMapValue_Zero(t *testing.T) {
	nilValue := new(uintIntMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uintIntMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint8IntMapValue_Zero(t *testing.T) {
	nilValue := new(uint8IntMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint8IntMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint16IntMapValue_Zero(t *testing.T) {
	nilValue := new(uint16IntMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint16IntMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint32IntMapValue_Zero(t *testing.T) {
	nilValue := new(uint32IntMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint32IntMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint64IntMapValue_Zero(t *testing.T) {
	nilValue := new(uint64IntMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint64IntMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIntSliceValue(t *testing.T) {
	t.Run("in: [10,20 -1]", func(t *testing.T) {
		var err error
		a := new([]int)
		v := newIntSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("10,20")
		assert.Nil(t, err)
		err = v.Set("-1")
		assert.Nil(t, err)
		assert.Equal(t, "[10,20,-1]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "intSlice", v.Type())
	})
	t.Run("in: [1,a]", func(t *testing.T) {
		var err error
		a := new([]int)
		v := newIntSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("1,a")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"a\": invalid syntax")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "intSlice", v.Type())
	})

}

func TestInt8Value_Zero(t *testing.T) {
	nilValue := new(int8Value)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int8Value)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt8Value(t *testing.T) {
	t.Run("in: 127", func(t *testing.T) {
		a := new(int8)
		v := newInt8Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("127")
		assert.Nil(t, err)
		assert.Equal(t, "127", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int8", v.Type())
	})
	t.Run("in: -128", func(t *testing.T) {
		a := new(int8)
		v := newInt8Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-128")
		assert.Nil(t, err)
		assert.Equal(t, "-128", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int8", v.Type())
	})
	t.Run("in: -129", func(t *testing.T) {
		a := new(int8)
		v := newInt8Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-129")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"-129\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int8", v.Type())
	})
	t.Run("in: 128", func(t *testing.T) {
		a := new(int8)
		v := newInt8Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("128")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"128\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int8", v.Type())
	})
	t.Run("in: a", func(t *testing.T) {
		a := new(int8)
		v := newInt8Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("a")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"a\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int8", v.Type())
	})

}

func TestInt8SliceValue_Zero(t *testing.T) {
	nilValue := new(int8SliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int8SliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestStringInt8MapValue_Zero(t *testing.T) {
	nilValue := new(stringInt8MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*stringInt8MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIntInt8MapValue_Zero(t *testing.T) {
	nilValue := new(intInt8MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*intInt8MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt8Int8MapValue_Zero(t *testing.T) {
	nilValue := new(int8Int8MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int8Int8MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt16Int8MapValue_Zero(t *testing.T) {
	nilValue := new(int16Int8MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int16Int8MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt32Int8MapValue_Zero(t *testing.T) {
	nilValue := new(int32Int8MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int32Int8MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt64Int8MapValue_Zero(t *testing.T) {
	nilValue := new(int64Int8MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int64Int8MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUintInt8MapValue_Zero(t *testing.T) {
	nilValue := new(uintInt8MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uintInt8MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint8Int8MapValue_Zero(t *testing.T) {
	nilValue := new(uint8Int8MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint8Int8MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint16Int8MapValue_Zero(t *testing.T) {
	nilValue := new(uint16Int8MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint16Int8MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint32Int8MapValue_Zero(t *testing.T) {
	nilValue := new(uint32Int8MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint32Int8MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint64Int8MapValue_Zero(t *testing.T) {
	nilValue := new(uint64Int8MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint64Int8MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt8SliceValue(t *testing.T) {
	t.Run("in: [10,20 -1]", func(t *testing.T) {
		var err error
		a := new([]int8)
		v := newInt8SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("10,20")
		assert.Nil(t, err)
		err = v.Set("-1")
		assert.Nil(t, err)
		assert.Equal(t, "[10,20,-1]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int8Slice", v.Type())
	})
	t.Run("in: [1,a]", func(t *testing.T) {
		var err error
		a := new([]int8)
		v := newInt8SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("1,a")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"a\": invalid syntax")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int8Slice", v.Type())
	})

}

func TestInt16Value_Zero(t *testing.T) {
	nilValue := new(int16Value)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int16Value)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt16Value(t *testing.T) {
	t.Run("in: 32767", func(t *testing.T) {
		a := new(int16)
		v := newInt16Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("32767")
		assert.Nil(t, err)
		assert.Equal(t, "32767", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int16", v.Type())
	})
	t.Run("in: -32768", func(t *testing.T) {
		a := new(int16)
		v := newInt16Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-32768")
		assert.Nil(t, err)
		assert.Equal(t, "-32768", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int16", v.Type())
	})
	t.Run("in: -32769", func(t *testing.T) {
		a := new(int16)
		v := newInt16Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-32769")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"-32769\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int16", v.Type())
	})
	t.Run("in: 32768", func(t *testing.T) {
		a := new(int16)
		v := newInt16Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("32768")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"32768\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int16", v.Type())
	})
	t.Run("in: a", func(t *testing.T) {
		a := new(int16)
		v := newInt16Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("a")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"a\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int16", v.Type())
	})

}

func TestInt16SliceValue_Zero(t *testing.T) {
	nilValue := new(int16SliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int16SliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestStringInt16MapValue_Zero(t *testing.T) {
	nilValue := new(stringInt16MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*stringInt16MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIntInt16MapValue_Zero(t *testing.T) {
	nilValue := new(intInt16MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*intInt16MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt8Int16MapValue_Zero(t *testing.T) {
	nilValue := new(int8Int16MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int8Int16MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt16Int16MapValue_Zero(t *testing.T) {
	nilValue := new(int16Int16MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int16Int16MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt32Int16MapValue_Zero(t *testing.T) {
	nilValue := new(int32Int16MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int32Int16MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt64Int16MapValue_Zero(t *testing.T) {
	nilValue := new(int64Int16MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int64Int16MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUintInt16MapValue_Zero(t *testing.T) {
	nilValue := new(uintInt16MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uintInt16MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint8Int16MapValue_Zero(t *testing.T) {
	nilValue := new(uint8Int16MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint8Int16MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint16Int16MapValue_Zero(t *testing.T) {
	nilValue := new(uint16Int16MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint16Int16MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint32Int16MapValue_Zero(t *testing.T) {
	nilValue := new(uint32Int16MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint32Int16MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint64Int16MapValue_Zero(t *testing.T) {
	nilValue := new(uint64Int16MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint64Int16MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt16SliceValue(t *testing.T) {
	t.Run("in: [10,20 -1]", func(t *testing.T) {
		var err error
		a := new([]int16)
		v := newInt16SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("10,20")
		assert.Nil(t, err)
		err = v.Set("-1")
		assert.Nil(t, err)
		assert.Equal(t, "[10,20,-1]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int16Slice", v.Type())
	})
	t.Run("in: [1,a]", func(t *testing.T) {
		var err error
		a := new([]int16)
		v := newInt16SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("1,a")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"a\": invalid syntax")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int16Slice", v.Type())
	})

}

func TestInt32Value_Zero(t *testing.T) {
	nilValue := new(int32Value)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int32Value)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt32Value(t *testing.T) {
	t.Run("in: 2147483647", func(t *testing.T) {
		a := new(int32)
		v := newInt32Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("2147483647")
		assert.Nil(t, err)
		assert.Equal(t, "2147483647", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int32", v.Type())
	})
	t.Run("in: -2147483648", func(t *testing.T) {
		a := new(int32)
		v := newInt32Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-2147483648")
		assert.Nil(t, err)
		assert.Equal(t, "-2147483648", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int32", v.Type())
	})
	t.Run("in: -2147483649", func(t *testing.T) {
		a := new(int32)
		v := newInt32Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-2147483649")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"-2147483649\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int32", v.Type())
	})
	t.Run("in: 2147483648", func(t *testing.T) {
		a := new(int32)
		v := newInt32Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("2147483648")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"2147483648\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int32", v.Type())
	})
	t.Run("in: a", func(t *testing.T) {
		a := new(int32)
		v := newInt32Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("a")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"a\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int32", v.Type())
	})

}

func TestInt32SliceValue_Zero(t *testing.T) {
	nilValue := new(int32SliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int32SliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestStringInt32MapValue_Zero(t *testing.T) {
	nilValue := new(stringInt32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*stringInt32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIntInt32MapValue_Zero(t *testing.T) {
	nilValue := new(intInt32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*intInt32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt8Int32MapValue_Zero(t *testing.T) {
	nilValue := new(int8Int32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int8Int32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt16Int32MapValue_Zero(t *testing.T) {
	nilValue := new(int16Int32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int16Int32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt32Int32MapValue_Zero(t *testing.T) {
	nilValue := new(int32Int32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int32Int32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt64Int32MapValue_Zero(t *testing.T) {
	nilValue := new(int64Int32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int64Int32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUintInt32MapValue_Zero(t *testing.T) {
	nilValue := new(uintInt32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uintInt32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint8Int32MapValue_Zero(t *testing.T) {
	nilValue := new(uint8Int32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint8Int32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint16Int32MapValue_Zero(t *testing.T) {
	nilValue := new(uint16Int32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint16Int32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint32Int32MapValue_Zero(t *testing.T) {
	nilValue := new(uint32Int32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint32Int32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint64Int32MapValue_Zero(t *testing.T) {
	nilValue := new(uint64Int32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint64Int32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt32SliceValue(t *testing.T) {
	t.Run("in: [10,20 -1]", func(t *testing.T) {
		var err error
		a := new([]int32)
		v := newInt32SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("10,20")
		assert.Nil(t, err)
		err = v.Set("-1")
		assert.Nil(t, err)
		assert.Equal(t, "[10,20,-1]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int32Slice", v.Type())
	})
	t.Run("in: [1,a]", func(t *testing.T) {
		var err error
		a := new([]int32)
		v := newInt32SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("1,a")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"a\": invalid syntax")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int32Slice", v.Type())
	})

}

func TestInt64Value_Zero(t *testing.T) {
	nilValue := new(int64Value)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int64Value)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt64Value(t *testing.T) {
	t.Run("in: 3", func(t *testing.T) {
		a := new(int64)
		v := newInt64Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("3")
		assert.Nil(t, err)
		assert.Equal(t, "3", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int64", v.Type())
	})
	t.Run("in: -3", func(t *testing.T) {
		a := new(int64)
		v := newInt64Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-3")
		assert.Nil(t, err)
		assert.Equal(t, "-3", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int64", v.Type())
	})
	t.Run("in: -9223372036854775809", func(t *testing.T) {
		a := new(int64)
		v := newInt64Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-9223372036854775809")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"-9223372036854775809\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int64", v.Type())
	})
	t.Run("in: 9223372036854775808", func(t *testing.T) {
		a := new(int64)
		v := newInt64Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("9223372036854775808")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"9223372036854775808\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int64", v.Type())
	})
	t.Run("in: a", func(t *testing.T) {
		a := new(int64)
		v := newInt64Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("a")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"a\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int64", v.Type())
	})

}

func TestInt64SliceValue_Zero(t *testing.T) {
	nilValue := new(int64SliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int64SliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestStringInt64MapValue_Zero(t *testing.T) {
	nilValue := new(stringInt64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*stringInt64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIntInt64MapValue_Zero(t *testing.T) {
	nilValue := new(intInt64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*intInt64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt8Int64MapValue_Zero(t *testing.T) {
	nilValue := new(int8Int64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int8Int64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt16Int64MapValue_Zero(t *testing.T) {
	nilValue := new(int16Int64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int16Int64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt32Int64MapValue_Zero(t *testing.T) {
	nilValue := new(int32Int64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int32Int64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt64Int64MapValue_Zero(t *testing.T) {
	nilValue := new(int64Int64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int64Int64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUintInt64MapValue_Zero(t *testing.T) {
	nilValue := new(uintInt64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uintInt64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint8Int64MapValue_Zero(t *testing.T) {
	nilValue := new(uint8Int64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint8Int64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint16Int64MapValue_Zero(t *testing.T) {
	nilValue := new(uint16Int64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint16Int64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint32Int64MapValue_Zero(t *testing.T) {
	nilValue := new(uint32Int64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint32Int64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint64Int64MapValue_Zero(t *testing.T) {
	nilValue := new(uint64Int64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint64Int64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt64SliceValue(t *testing.T) {
	t.Run("in: [10,20 -1]", func(t *testing.T) {
		var err error
		a := new([]int64)
		v := newInt64SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("10,20")
		assert.Nil(t, err)
		err = v.Set("-1")
		assert.Nil(t, err)
		assert.Equal(t, "[10,20,-1]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int64Slice", v.Type())
	})
	t.Run("in: [1,a]", func(t *testing.T) {
		var err error
		a := new([]int64)
		v := newInt64SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("1,a")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"a\": invalid syntax")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int64Slice", v.Type())
	})

}

func TestFloat64Value_Zero(t *testing.T) {
	nilValue := new(float64Value)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*float64Value)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestFloat64Value(t *testing.T) {
	t.Run("in: 11.11", func(t *testing.T) {
		a := new(float64)
		v := newFloat64Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("11.11")
		assert.Nil(t, err)
		assert.Equal(t, "11.11", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "float64", v.Type())
	})
	t.Run("in: 11.11.11", func(t *testing.T) {
		a := new(float64)
		v := newFloat64Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("11.11.11")
		assert.EqualError(t, err, "strconv.ParseFloat: parsing \"11.11.11\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "float64", v.Type())
	})
	t.Run("in: a", func(t *testing.T) {
		a := new(float64)
		v := newFloat64Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("a")
		assert.EqualError(t, err, "strconv.ParseFloat: parsing \"a\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "float64", v.Type())
	})

}

func TestFloat64SliceValue_Zero(t *testing.T) {
	nilValue := new(float64SliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*float64SliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestStringFloat64MapValue_Zero(t *testing.T) {
	nilValue := new(stringFloat64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*stringFloat64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIntFloat64MapValue_Zero(t *testing.T) {
	nilValue := new(intFloat64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*intFloat64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt8Float64MapValue_Zero(t *testing.T) {
	nilValue := new(int8Float64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int8Float64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt16Float64MapValue_Zero(t *testing.T) {
	nilValue := new(int16Float64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int16Float64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt32Float64MapValue_Zero(t *testing.T) {
	nilValue := new(int32Float64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int32Float64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt64Float64MapValue_Zero(t *testing.T) {
	nilValue := new(int64Float64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int64Float64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUintFloat64MapValue_Zero(t *testing.T) {
	nilValue := new(uintFloat64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uintFloat64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint8Float64MapValue_Zero(t *testing.T) {
	nilValue := new(uint8Float64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint8Float64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint16Float64MapValue_Zero(t *testing.T) {
	nilValue := new(uint16Float64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint16Float64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint32Float64MapValue_Zero(t *testing.T) {
	nilValue := new(uint32Float64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint32Float64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint64Float64MapValue_Zero(t *testing.T) {
	nilValue := new(uint64Float64MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint64Float64MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestFloat64SliceValue(t *testing.T) {
	t.Run("in: [10.2,20.99 3.4]", func(t *testing.T) {
		var err error
		a := new([]float64)
		v := newFloat64SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("10.2,20.99")
		assert.Nil(t, err)
		err = v.Set("3.4")
		assert.Nil(t, err)
		assert.Equal(t, "[10.2,20.99,3.4]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "float64Slice", v.Type())
	})
	t.Run("in: [1,a]", func(t *testing.T) {
		var err error
		a := new([]float64)
		v := newFloat64SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("1,a")
		assert.EqualError(t, err, "strconv.ParseFloat: parsing \"a\": invalid syntax")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "float64Slice", v.Type())
	})

}

func TestFloat32Value_Zero(t *testing.T) {
	nilValue := new(float32Value)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*float32Value)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestFloat32Value(t *testing.T) {
	t.Run("in: 11.11", func(t *testing.T) {
		a := new(float32)
		v := newFloat32Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("11.11")
		assert.Nil(t, err)
		assert.Equal(t, "11.11", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "float32", v.Type())
	})
	t.Run("in: 11.11.11", func(t *testing.T) {
		a := new(float32)
		v := newFloat32Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("11.11.11")
		assert.EqualError(t, err, "strconv.ParseFloat: parsing \"11.11.11\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "float32", v.Type())
	})
	t.Run("in: a", func(t *testing.T) {
		a := new(float32)
		v := newFloat32Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("a")
		assert.EqualError(t, err, "strconv.ParseFloat: parsing \"a\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "float32", v.Type())
	})

}

func TestFloat32SliceValue_Zero(t *testing.T) {
	nilValue := new(float32SliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*float32SliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestStringFloat32MapValue_Zero(t *testing.T) {
	nilValue := new(stringFloat32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*stringFloat32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIntFloat32MapValue_Zero(t *testing.T) {
	nilValue := new(intFloat32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*intFloat32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt8Float32MapValue_Zero(t *testing.T) {
	nilValue := new(int8Float32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int8Float32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt16Float32MapValue_Zero(t *testing.T) {
	nilValue := new(int16Float32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int16Float32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt32Float32MapValue_Zero(t *testing.T) {
	nilValue := new(int32Float32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int32Float32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt64Float32MapValue_Zero(t *testing.T) {
	nilValue := new(int64Float32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int64Float32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUintFloat32MapValue_Zero(t *testing.T) {
	nilValue := new(uintFloat32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uintFloat32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint8Float32MapValue_Zero(t *testing.T) {
	nilValue := new(uint8Float32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint8Float32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint16Float32MapValue_Zero(t *testing.T) {
	nilValue := new(uint16Float32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint16Float32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint32Float32MapValue_Zero(t *testing.T) {
	nilValue := new(uint32Float32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint32Float32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint64Float32MapValue_Zero(t *testing.T) {
	nilValue := new(uint64Float32MapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint64Float32MapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestFloat32SliceValue(t *testing.T) {
	t.Run("in: [10.2,20.99 3.4]", func(t *testing.T) {
		var err error
		a := new([]float32)
		v := newFloat32SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("10.2,20.99")
		assert.Nil(t, err)
		err = v.Set("3.4")
		assert.Nil(t, err)
		assert.Equal(t, "[10.2,20.99,3.4]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "float32Slice", v.Type())
	})
	t.Run("in: [1,a]", func(t *testing.T) {
		var err error
		a := new([]float32)
		v := newFloat32SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("1,a")
		assert.EqualError(t, err, "strconv.ParseFloat: parsing \"a\": invalid syntax")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "float32Slice", v.Type())
	})

}

func TestDurationValue_Zero(t *testing.T) {
	nilValue := new(durationValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*durationValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestDurationValue(t *testing.T) {
	t.Run("in: 3s", func(t *testing.T) {
		a := new(time.Duration)
		v := newDurationValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("3s")
		assert.Nil(t, err)
		assert.Equal(t, "3s", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "duration", v.Type())
	})
	t.Run("in: 3l", func(t *testing.T) {
		a := new(time.Duration)
		v := newDurationValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("3l")
		assert.EqualError(t, err, "time: unknown unit l in duration 3l")
		assert.Equal(t, "0s", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "duration", v.Type())
	})

}

func TestDurationSliceValue_Zero(t *testing.T) {
	nilValue := new(durationSliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*durationSliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestStringDurationMapValue_Zero(t *testing.T) {
	nilValue := new(stringDurationMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*stringDurationMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIntDurationMapValue_Zero(t *testing.T) {
	nilValue := new(intDurationMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*intDurationMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt8DurationMapValue_Zero(t *testing.T) {
	nilValue := new(int8DurationMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int8DurationMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt16DurationMapValue_Zero(t *testing.T) {
	nilValue := new(int16DurationMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int16DurationMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt32DurationMapValue_Zero(t *testing.T) {
	nilValue := new(int32DurationMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int32DurationMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt64DurationMapValue_Zero(t *testing.T) {
	nilValue := new(int64DurationMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int64DurationMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUintDurationMapValue_Zero(t *testing.T) {
	nilValue := new(uintDurationMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uintDurationMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint8DurationMapValue_Zero(t *testing.T) {
	nilValue := new(uint8DurationMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint8DurationMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint16DurationMapValue_Zero(t *testing.T) {
	nilValue := new(uint16DurationMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint16DurationMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint32DurationMapValue_Zero(t *testing.T) {
	nilValue := new(uint32DurationMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint32DurationMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint64DurationMapValue_Zero(t *testing.T) {
	nilValue := new(uint64DurationMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint64DurationMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestDurationSliceValue(t *testing.T) {
	t.Run("in: [10s,30m 1ms]", func(t *testing.T) {
		var err error
		a := new([]time.Duration)
		v := newDurationSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("10s,30m")
		assert.Nil(t, err)
		err = v.Set("1ms")
		assert.Nil(t, err)
		assert.Equal(t, "[10s,30m0s,1ms]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "durationSlice", v.Type())
	})
	t.Run("in: [1s,3l]", func(t *testing.T) {
		var err error
		a := new([]time.Duration)
		v := newDurationSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("1s,3l")
		assert.EqualError(t, err, "time: unknown unit l in duration 3l")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "durationSlice", v.Type())
	})

}

func TestIPValue_Zero(t *testing.T) {
	nilValue := new(ipValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*ipValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIPValue(t *testing.T) {
	t.Run("in: 127.0.0.1", func(t *testing.T) {
		a := new(net.IP)
		v := newIPValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("127.0.0.1")
		assert.Nil(t, err)
		assert.Equal(t, "127.0.0.1", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "ip", v.Type())
	})
	t.Run("in: 127.0.0.1.3", func(t *testing.T) {
		a := new(net.IP)
		v := newIPValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("127.0.0.1.3")
		assert.EqualError(t, err, "failed to parse IP: \"127.0.0.1.3\"")
		assert.Equal(t, "<nil>", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "ip", v.Type())
	})

}

func TestIPSliceValue_Zero(t *testing.T) {
	nilValue := new(ipSliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*ipSliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestStringIPMapValue_Zero(t *testing.T) {
	nilValue := new(stringIPMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*stringIPMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIntIPMapValue_Zero(t *testing.T) {
	nilValue := new(intIPMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*intIPMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt8IPMapValue_Zero(t *testing.T) {
	nilValue := new(int8IPMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int8IPMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt16IPMapValue_Zero(t *testing.T) {
	nilValue := new(int16IPMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int16IPMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt32IPMapValue_Zero(t *testing.T) {
	nilValue := new(int32IPMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int32IPMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt64IPMapValue_Zero(t *testing.T) {
	nilValue := new(int64IPMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int64IPMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUintIPMapValue_Zero(t *testing.T) {
	nilValue := new(uintIPMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uintIPMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint8IPMapValue_Zero(t *testing.T) {
	nilValue := new(uint8IPMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint8IPMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint16IPMapValue_Zero(t *testing.T) {
	nilValue := new(uint16IPMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint16IPMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint32IPMapValue_Zero(t *testing.T) {
	nilValue := new(uint32IPMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint32IPMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint64IPMapValue_Zero(t *testing.T) {
	nilValue := new(uint64IPMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint64IPMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIPSliceValue(t *testing.T) {
	t.Run("in: [127.0.0.1,127.0.0.2 127.0.0.3]", func(t *testing.T) {
		var err error
		a := new([]net.IP)
		v := newIPSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("127.0.0.1,127.0.0.2")
		assert.Nil(t, err)
		err = v.Set("127.0.0.3")
		assert.Nil(t, err)
		assert.Equal(t, "[127.0.0.1,127.0.0.2,127.0.0.3]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "ipSlice", v.Type())
	})
	t.Run("in: [127.0.0.3,127.0.0.1.3]", func(t *testing.T) {
		var err error
		a := new([]net.IP)
		v := newIPSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("127.0.0.3,127.0.0.1.3")
		assert.EqualError(t, err, "failed to parse IP: \"127.0.0.1.3\"")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "ipSlice", v.Type())
	})

}

func TestHexBytesValue_Zero(t *testing.T) {
	nilValue := new(hexBytesValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*hexBytesValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestHexBytesValue(t *testing.T) {
	t.Run("in: ffffff", func(t *testing.T) {
		a := new(HexBytes)
		v := newHexBytesValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("ffffff")
		assert.Nil(t, err)
		assert.Equal(t, "ffffff", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "hexBytes", v.Type())
	})
	t.Run("in: FFFFFF", func(t *testing.T) {
		a := new(HexBytes)
		v := newHexBytesValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("FFFFFF")
		assert.Nil(t, err)
		assert.Equal(t, "ffffff", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "hexBytes", v.Type())
	})
	t.Run("in: a", func(t *testing.T) {
		a := new(HexBytes)
		v := newHexBytesValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("a")
		assert.EqualError(t, err, "encoding/hex: odd length hex string")
		assert.Equal(t, "", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "hexBytes", v.Type())
	})
	t.Run("in: gg", func(t *testing.T) {
		a := new(HexBytes)
		v := newHexBytesValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("gg")
		assert.EqualError(t, err, "encoding/hex: invalid byte: U+0067 'g'")
		assert.Equal(t, "", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "hexBytes", v.Type())
	})

}

func TestHexBytesSliceValue_Zero(t *testing.T) {
	nilValue := new(hexBytesSliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*hexBytesSliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestStringHexBytesMapValue_Zero(t *testing.T) {
	nilValue := new(stringHexBytesMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*stringHexBytesMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIntHexBytesMapValue_Zero(t *testing.T) {
	nilValue := new(intHexBytesMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*intHexBytesMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt8HexBytesMapValue_Zero(t *testing.T) {
	nilValue := new(int8HexBytesMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int8HexBytesMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt16HexBytesMapValue_Zero(t *testing.T) {
	nilValue := new(int16HexBytesMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int16HexBytesMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt32HexBytesMapValue_Zero(t *testing.T) {
	nilValue := new(int32HexBytesMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int32HexBytesMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt64HexBytesMapValue_Zero(t *testing.T) {
	nilValue := new(int64HexBytesMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int64HexBytesMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUintHexBytesMapValue_Zero(t *testing.T) {
	nilValue := new(uintHexBytesMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uintHexBytesMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint8HexBytesMapValue_Zero(t *testing.T) {
	nilValue := new(uint8HexBytesMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint8HexBytesMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint16HexBytesMapValue_Zero(t *testing.T) {
	nilValue := new(uint16HexBytesMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint16HexBytesMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint32HexBytesMapValue_Zero(t *testing.T) {
	nilValue := new(uint32HexBytesMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint32HexBytesMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint64HexBytesMapValue_Zero(t *testing.T) {
	nilValue := new(uint64HexBytesMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint64HexBytesMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestHexBytesSliceValue(t *testing.T) {
	t.Run("in: [ff,aa,bb cc]", func(t *testing.T) {
		var err error
		a := new([]HexBytes)
		v := newHexBytesSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("ff,aa,bb")
		assert.Nil(t, err)
		err = v.Set("cc")
		assert.Nil(t, err)
		assert.Equal(t, "[ff,aa,bb,cc]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "hexBytesSlice", v.Type())
	})
	t.Run("in: [ff,gg]", func(t *testing.T) {
		var err error
		a := new([]HexBytes)
		v := newHexBytesSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("ff,gg")
		assert.EqualError(t, err, "encoding/hex: invalid byte: U+0067 'g'")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "hexBytesSlice", v.Type())
	})

}

func TestRegexpValue_Zero(t *testing.T) {
	nilValue := new(regexpValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*regexpValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestRegexpValue(t *testing.T) {
	t.Run("in: abcdef.*", func(t *testing.T) {
		a := new(regexp.Regexp)
		v := newRegexpValue(&a)
		assert.Equal(t, parseGeneratedPtrs(&a), v)
		err := v.Set("abcdef.*")
		assert.Nil(t, err)
		assert.Equal(t, "abcdef.*", v.String())
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "regexp", v.Type())
	})
	t.Run("in: [abc", func(t *testing.T) {
		a := new(regexp.Regexp)
		v := newRegexpValue(&a)
		assert.Equal(t, parseGeneratedPtrs(&a), v)
		err := v.Set("[abc")
		assert.EqualError(t, err, "error parsing regexp: missing closing ]: `[abc`")
		assert.Equal(t, "", v.String())
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "regexp", v.Type())
	})

}

func TestRegexpSliceValue_Zero(t *testing.T) {
	nilValue := new(regexpSliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*regexpSliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestStringRegexpMapValue_Zero(t *testing.T) {
	nilValue := new(stringRegexpMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*stringRegexpMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIntRegexpMapValue_Zero(t *testing.T) {
	nilValue := new(intRegexpMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*intRegexpMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt8RegexpMapValue_Zero(t *testing.T) {
	nilValue := new(int8RegexpMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int8RegexpMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt16RegexpMapValue_Zero(t *testing.T) {
	nilValue := new(int16RegexpMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int16RegexpMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt32RegexpMapValue_Zero(t *testing.T) {
	nilValue := new(int32RegexpMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int32RegexpMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt64RegexpMapValue_Zero(t *testing.T) {
	nilValue := new(int64RegexpMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int64RegexpMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUintRegexpMapValue_Zero(t *testing.T) {
	nilValue := new(uintRegexpMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uintRegexpMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint8RegexpMapValue_Zero(t *testing.T) {
	nilValue := new(uint8RegexpMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint8RegexpMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint16RegexpMapValue_Zero(t *testing.T) {
	nilValue := new(uint16RegexpMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint16RegexpMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint32RegexpMapValue_Zero(t *testing.T) {
	nilValue := new(uint32RegexpMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint32RegexpMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint64RegexpMapValue_Zero(t *testing.T) {
	nilValue := new(uint64RegexpMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint64RegexpMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestRegexpSliceValue(t *testing.T) {
	t.Run("in: [abc.*,def.* xyz.*]", func(t *testing.T) {
		var err error
		a := new([]*regexp.Regexp)
		v := newRegexpSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("abc.*,def.*")
		assert.Nil(t, err)
		err = v.Set("xyz.*")
		assert.Nil(t, err)
		assert.Equal(t, "[abc.*,def.*,xyz.*]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "regexpSlice", v.Type())
	})
	t.Run("in: [[abc,def]", func(t *testing.T) {
		var err error
		a := new([]*regexp.Regexp)
		v := newRegexpSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("[abc,def")
		assert.EqualError(t, err, "error parsing regexp: missing closing ]: `[abc`")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "regexpSlice", v.Type())
	})

}

func TestTCPAddrValue_Zero(t *testing.T) {
	nilValue := new(tcpAddrValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*tcpAddrValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestTCPAddrValue(t *testing.T) {
	t.Run("in: 127.0.0.1:8000", func(t *testing.T) {
		a := new(net.TCPAddr)
		v := newTCPAddrValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("127.0.0.1:8000")
		assert.Nil(t, err)
		assert.Equal(t, "127.0.0.1:8000", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "tcpAddr", v.Type())
	})
	t.Run("in: localhost:80", func(t *testing.T) {
		a := new(net.TCPAddr)
		v := newTCPAddrValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("localhost:80")
		assert.Nil(t, err)
		assert.Equal(t, "127.0.0.1:80", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "tcpAddr", v.Type())
	})
	t.Run("in: 127.0.0.1", func(t *testing.T) {
		a := new(net.TCPAddr)
		v := newTCPAddrValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("127.0.0.1")
		assert.EqualError(t, err, "failed to parse TCPAddr: \"127.0.0.1\"")
		assert.Equal(t, ":0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "tcpAddr", v.Type())
	})
	t.Run("in: 127.0.0.1.3:8000", func(t *testing.T) {
		a := new(net.TCPAddr)
		v := newTCPAddrValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("127.0.0.1.3:8000")
		assert.EqualError(t, err, "failed to parse TCPAddr: \"127.0.0.1.3:8000\"")
		assert.Equal(t, ":0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "tcpAddr", v.Type())
	})

}

func TestTCPAddrSliceValue_Zero(t *testing.T) {
	nilValue := new(tcpAddrSliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*tcpAddrSliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestStringTCPAddrMapValue_Zero(t *testing.T) {
	nilValue := new(stringTCPAddrMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*stringTCPAddrMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIntTCPAddrMapValue_Zero(t *testing.T) {
	nilValue := new(intTCPAddrMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*intTCPAddrMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt8TCPAddrMapValue_Zero(t *testing.T) {
	nilValue := new(int8TCPAddrMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int8TCPAddrMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt16TCPAddrMapValue_Zero(t *testing.T) {
	nilValue := new(int16TCPAddrMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int16TCPAddrMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt32TCPAddrMapValue_Zero(t *testing.T) {
	nilValue := new(int32TCPAddrMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int32TCPAddrMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt64TCPAddrMapValue_Zero(t *testing.T) {
	nilValue := new(int64TCPAddrMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int64TCPAddrMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUintTCPAddrMapValue_Zero(t *testing.T) {
	nilValue := new(uintTCPAddrMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uintTCPAddrMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint8TCPAddrMapValue_Zero(t *testing.T) {
	nilValue := new(uint8TCPAddrMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint8TCPAddrMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint16TCPAddrMapValue_Zero(t *testing.T) {
	nilValue := new(uint16TCPAddrMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint16TCPAddrMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint32TCPAddrMapValue_Zero(t *testing.T) {
	nilValue := new(uint32TCPAddrMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint32TCPAddrMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint64TCPAddrMapValue_Zero(t *testing.T) {
	nilValue := new(uint64TCPAddrMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint64TCPAddrMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestTCPAddrSliceValue(t *testing.T) {
	t.Run("in: [127.0.0.1:80,127.0.0.2:80 127.0.0.3:8800]", func(t *testing.T) {
		var err error
		a := new([]net.TCPAddr)
		v := newTCPAddrSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("127.0.0.1:80,127.0.0.2:80")
		assert.Nil(t, err)
		err = v.Set("127.0.0.3:8800")
		assert.Nil(t, err)
		assert.Equal(t, "[127.0.0.1:80,127.0.0.2:80,127.0.0.3:8800]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "tcpAddrSlice", v.Type())
	})
	t.Run("in: [127.0.0.3:8000,127.0.0.1.3:8000]", func(t *testing.T) {
		var err error
		a := new([]net.TCPAddr)
		v := newTCPAddrSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("127.0.0.3:8000,127.0.0.1.3:8000")
		assert.EqualError(t, err, "failed to parse TCPAddr: \"127.0.0.1.3:8000\"")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "tcpAddrSlice", v.Type())
	})

}

func TestIPNetValue_Zero(t *testing.T) {
	nilValue := new(ipNetValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*ipNetValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIPNetValue(t *testing.T) {
	t.Run("in: 0.0.0.0/0", func(t *testing.T) {
		a := new(net.IPNet)
		v := newIPNetValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("0.0.0.0/0")
		assert.Nil(t, err)
		assert.Equal(t, "0.0.0.0/0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "ipNet", v.Type())
	})
	t.Run("in: 1.2.3.4/8", func(t *testing.T) {
		a := new(net.IPNet)
		v := newIPNetValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("1.2.3.4/8")
		assert.Nil(t, err)
		assert.Equal(t, "1.0.0.0/8", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "ipNet", v.Type())
	})
	t.Run("in: 255.255.255.255/19", func(t *testing.T) {
		a := new(net.IPNet)
		v := newIPNetValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("255.255.255.255/19")
		assert.Nil(t, err)
		assert.Equal(t, "255.255.224.0/19", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "ipNet", v.Type())
	})
	t.Run("in: 255.255.255.255/32", func(t *testing.T) {
		a := new(net.IPNet)
		v := newIPNetValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("255.255.255.255/32")
		assert.Nil(t, err)
		assert.Equal(t, "255.255.255.255/32", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "ipNet", v.Type())
	})
	t.Run("in: ", func(t *testing.T) {
		a := new(net.IPNet)
		v := newIPNetValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("")
		assert.EqualError(t, err, "invalid CIDR address: ")
		assert.Equal(t, "<nil>", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "ipNet", v.Type())
	})
	t.Run("in: 0.0.0.256/16", func(t *testing.T) {
		a := new(net.IPNet)
		v := newIPNetValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("0.0.0.256/16")
		assert.EqualError(t, err, "invalid CIDR address: 0.0.0.256/16")
		assert.Equal(t, "<nil>", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "ipNet", v.Type())
	})

}

func TestIPNetSliceValue_Zero(t *testing.T) {
	nilValue := new(ipNetSliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*ipNetSliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestStringIPNetMapValue_Zero(t *testing.T) {
	nilValue := new(stringIPNetMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*stringIPNetMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIntIPNetMapValue_Zero(t *testing.T) {
	nilValue := new(intIPNetMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*intIPNetMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt8IPNetMapValue_Zero(t *testing.T) {
	nilValue := new(int8IPNetMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int8IPNetMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt16IPNetMapValue_Zero(t *testing.T) {
	nilValue := new(int16IPNetMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int16IPNetMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt32IPNetMapValue_Zero(t *testing.T) {
	nilValue := new(int32IPNetMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int32IPNetMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt64IPNetMapValue_Zero(t *testing.T) {
	nilValue := new(int64IPNetMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int64IPNetMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUintIPNetMapValue_Zero(t *testing.T) {
	nilValue := new(uintIPNetMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uintIPNetMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint8IPNetMapValue_Zero(t *testing.T) {
	nilValue := new(uint8IPNetMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint8IPNetMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint16IPNetMapValue_Zero(t *testing.T) {
	nilValue := new(uint16IPNetMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint16IPNetMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint32IPNetMapValue_Zero(t *testing.T) {
	nilValue := new(uint32IPNetMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint32IPNetMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint64IPNetMapValue_Zero(t *testing.T) {
	nilValue := new(uint64IPNetMapValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint64IPNetMapValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIPNetSliceValue(t *testing.T) {
	t.Run("in: [0.0.0.0/0,1.2.3.4/8 255.255.255.255/19]", func(t *testing.T) {
		var err error
		a := new([]net.IPNet)
		v := newIPNetSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("0.0.0.0/0,1.2.3.4/8")
		assert.Nil(t, err)
		err = v.Set("255.255.255.255/19")
		assert.Nil(t, err)
		assert.Equal(t, "[0.0.0.0/0,1.0.0.0/8,255.255.224.0/19]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "ipNetSlice", v.Type())
	})
	t.Run("in: [0.0.0.0/0,0.0.0.256/16]", func(t *testing.T) {
		var err error
		a := new([]net.IPNet)
		v := newIPNetSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("0.0.0.0/0,0.0.0.256/16")
		assert.EqualError(t, err, "invalid CIDR address: 0.0.0.256/16")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "ipNetSlice", v.Type())
	})

}
